import { entitiesInfos } from "../collection";
import type { Entity } from "../entity";
import type { CollectionProperties } from "../entityMetadata";
import type { SecurityInfo } from "./securityDecorators";
import { rootCollections, securityInfos } from "./securityDecorators";

export const createSecurityRules = (): string => {
    return `
// generated by script
rules_version = "2";
service cloud.firestore {
    match /databases/{database}/documents {
        ${rootCollections
            .map((rootCollection) => {
                return createCollectionRules(rootCollection);
            })
            .join("")}
    }
}
    `;
};

const createCollectionRules = (
    collectionName: string,
    modelNamespace?: string,
    blacklistedProperties?: string[],
    parentModelNamespace?: string,
): string => {
    if (modelNamespace === undefined) modelNamespace = collectionName;
    const entitiesInfo = entitiesInfos.get(modelNamespace);
    if (entitiesInfo === undefined) {
        throw new Error(`Collection ${modelNamespace} is not defined`);
    }
    const { documentProperties, collectionProperties } = getProperties(
        entitiesInfo.model,
    );
    const collectionSecurityOptions = securityInfos.get(
        parentModelNamespace === undefined
            ? collectionName
            : `${parentModelNamespace}/${collectionName}`,
    );

    const rules: string[] = [];
    rules.push(createReadRule("get", collectionSecurityOptions?.security?.get));
    rules.push(createReadRule("list", collectionSecurityOptions?.security?.list));
    rules.push(
        createWriteRule(
            "create",
            collectionSecurityOptions?.security?.create,
            documentProperties,
            collectionSecurityOptions,
        ),
    );
    rules.push(
        createWriteRule(
            "update",
            collectionSecurityOptions?.security?.update,
            documentProperties,
            collectionSecurityOptions,
        ),
    );
    rules.push(
        createWriteRule(
            "delete",
            collectionSecurityOptions?.security?.delete,
            [],
            collectionSecurityOptions,
        ),
    );

    const subCollectionsRules = Object.entries(collectionProperties)
        .filter(
            ([collectionProperty]) =>
                !blacklistedProperties?.includes(collectionProperty),
        )
        .map(([collectionProperty, { namespace, blacklistedProperties }]) => {
            return createCollectionRules(
                collectionProperty,
                namespace,
                blacklistedProperties,
                modelNamespace,
            );
        });

    return `
        // ${modelNamespace}
        match /${collectionName}/{${modelNamespace}Id} {
            ${rules.filter((rule) => rule !== "").join("\n            ")}
            ${subCollectionsRules.join("").replaceAll("\n", "\n    ")}
        }
`;
};

const createReadRule = (rule: "get" | "list", ruleContent: string | undefined) => {
    if (ruleContent === undefined || ruleContent === "false") {
        return "";
    }
    return `allow ${rule}: if ${ruleContent};`;
};

const createWriteRule = (
    rule: "create" | "update" | "delete",
    ruleContent: string | undefined,
    documentProperties: string[],
    collectionSecurityOptions: SecurityInfo | undefined,
) => {
    if (ruleContent === undefined || ruleContent === "false") {
        return "";
    }
    if (ruleContent === "true") {
        return `allow ${rule}: if true;`;
    }
    const documentPropertiesCheck =
        documentProperties.length > 0
            ? `${createModelWritePropertiesRules(documentProperties)} && `
            : "";
    return `allow ${rule}: if ${documentPropertiesCheck}(${ruleContent}) ${createPropertiesRules(
        documentProperties,
        collectionSecurityOptions,
        rule,
    )};`;
};

const createModelWritePropertiesRules = (properties: string[]): string => {
    return `request.resource.data.keys().hasOnly(["${properties.join('","')}"])`;
};

const getProperties = (
    model: typeof Entity,
): {
    documentProperties: string[];
    collectionProperties: CollectionProperties;
} => {
    const entity = new model();
    const metadata = entity.$getMetadata();
    const documentProperties = Object.getOwnPropertyNames(metadata.properties);
    documentProperties.push("originalId");
    return {
        documentProperties,
        collectionProperties: metadata.collectionProperties,
    };
};

const createPropertiesRules = (
    properties: string[],
    modelSecurity: SecurityInfo | undefined,
    operation: "create" | "update" | "delete",
): string => {
    const propertiesRules = properties.filter(
        (property) => modelSecurity?.properties?.[property]?.[operation] !== undefined,
    );
    if (propertiesRules.length === 0) {
        return "";
    }
    return `&& (${propertiesRules
        .map((property) => {
            const rule = modelSecurity?.properties?.[property][operation];
            if (rule === "false")
                return `!request.resource.data.keys().hasAny(["${property}"])`;
            return `(!request.resource.data.keys().hasAny(["${property}"]) || ${modelSecurity?.properties?.[property][operation]})`;
        })
        .join(" && ")})`;
};
